## Основные команды работы с Git Bash <br>


1. pwd - показать рабочую папку
2. cd <имя_папки> - сменить папку (~ быстрый переход в домашнюю директорию; .. возврат на уровень выше; . обращение к текущей директории)
3. ls - вывести содержимое директории (-a для расширенного списка, со скрытыми файлами и папками)
4. touch <имя_файла> - создать файл в директории (лучше сразу указывать расширение файла)
5. mkdir <имя_папки> - создать папку (-p позволит создать структуру директорий dir1/dir2/dir...)
6. cp <что_копируем> <куда_копируем> - копировать файл
7. mv <список_папок_и_файлов> <куда_переместить> - переместить файлы и папки 
8. cat <имя_файла> - распечатать содержимое файла (работает с текстовыми файлами)
9. rm <имя_файла> - удалить файл
10. rmdir <имя_папки> - удалить папку (если она пустая)
11. rm -r <имя_папки> - удалить папку со всем ее содержимым (-r рекурсивно)
<br> 

---

<br>
Для упрошения работы с командной строкой можно использовать: <br>
- && соединить несколько команд и выполнить одновременно
<br>
- Tab автозаполнение (начать вводить команду или название папки и tab допишет нужное; 2 нажатия tab выдадут возможные варианты заполнения)
<br>


---


<br>


## Настройка и работа с Git <br>



После регистрации на GitHub и создания удаленного репозитория, можно приступать к их связываныванию. <br>
Для безопасной работы создадим SSH-ключи.
Обычно SSH-ключи находятся в директории .ssh/. Проверить наличие этой директории и файлов в ней можно с помощью следующей команды. <br>

```
$ cd ~ # перешли в домашнюю директорию
$ ls -la .ssh/ # вывели список созданных ключей 
```
<br>
Если папка пустая или её нет, всё в порядке. Если она не пустая и вы не создавали эти файлы, то ее следует удалить.
<br>
Сгенерируем SSH-ключи: <br>

```
$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 
```

<br> Если все прошло успешно, то получим сообщение: <br>
Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи 
<br>
Далее несколько раз нажимаем Enter (Кодовую фразу можно не вводить. Если она введина, то далее придется использовать ее в работе.).
Проверка, что в папке созданы ключи ls -a ~/.ssh. SSH-ключ состоит из двух частей — публичной и приватной. Публичный ключ зашифрует данные, а приватный — расшифрует. Приватным ключом ни в коем случае нельзя делиться.
<br>
В настройках GitHub-аккаунта нужно привязать публичный ключ (с расширением .pub). Подробнее информацию можно получить в [курсе по git.](https://practicum.yandex.ru/git-basics/?from=catalog)
<br>


---

<br>
Откройте консоль, перейдите в каталог локального репозитория и введите команду git remote add (от англ. remote — «удалённый» и add — «добавить»). <br>

```
$ cd ~/имя_папки_с_проектом
$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/удаленный_репозиторий.git 
```
<br>
Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово origin. А URL вы скопировали со страницы удалённого репозитория.
<br>
Убедиться, что репозитории связаны — git remote -v <br>
Каждый коммит сохраняет актуальное состояние файлов. Сами же коммиты хранятся в ветках (англ. branch). <br>
В репозитории может существовать сразу несколько веток — параллельных историй изменений. Также они могут соединяться друг с другом. <br>
Самая первая ветка в репозитории появляется автоматически и называется main (англ. «основная») или master. Её имя нужно указывать при отправке коммитов на удалённый репозиторий или при получении их из него.<br>
<br>

---

<br>

### Основные команды работы с git: <br>


- git config --global user.name "ваше_имя"  - устанавливает имя <br>
- git config --global user.email электронная_почта  - устанавливает почту <br>
- git config --list  - покажет список настроек <br>
- git init - пометит папку как репозиторий git и начнет отслеживать изменения <br>
- git status - проверка состояния репозитория (название ветки, коммиты, список изменений файлов) <br>
Новые файлы в папке не отслеживаются и имеют статус untracked. 
- git add имя_файла - подготовка сохранения по 1 (git add -all или git add . подготовит все файлы в репозитории) <br>
Данная команда не сохраняет содержимое файлов в репозитории. Само сохранение, фиксацию состояния в репозитории, называют коммитом. <br>
- git commit -m "сообщение к коммиту" - создание коммита<br>
Коммит гарантирует, что изменения будут сохранены и при необходимости к ним можно откатиться. <br>
Вы уже прошли весь «цикл коммита»: подготовили файлы с помощью git add, закоммитили их с комментарием командой git commit -m. Осталось загрузить содержимое локального репозитория на GitHub. За это отвечает команда git push (от англ. push — «толкать»). <br>
В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). Флаг -u свяжет локальную ветку с одноимённой удалённой. <br>

```
git push -u origin main 
```

<br>
При взаимодействии с удалёнными репозиториями Git выводит в консоль отладочную информацию: количество объектов (файлов), которые отправляются на сервер, информацию о прогрессе сжатия и записи и так далее.
Если вы указывали кодовую фразу при настройке SSH-ключей, её нужно будет ввести.
<br>
В дальнейшем при работе с удалённым репозиторием флаг -u можно опустить и писать просто git push. <br>


---

### Хеш — идентификатор коммита <br>

Хеширование — это способ преобразовать набор данных и получить их «отпечаток» (англ. fingerprint).
Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит.
Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.
Обычно хеш — это короткая (40 символов в случае SHA-1) строка, которая состоит из цифр 0—9 и латинских букв A—F (неважно, заглавных или строчных). <br>
Она обладает следующими важными свойствами: <br>

- если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
- если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

<br>
Git хранит таблицу соответствий хеш → информация о коммите. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.
<br>
Все хеши и таблицу хеш → информация о коммите Git сохраняет в служебные файлы. Они находятся в скрытой папке .git в репозитории проекта.
<br>

---

### Исследуем log

После вызова git log появляется список коммитов.<br>
Разберём элементы, из которых состоит описание:<br>

- строка из цифр и латинских букв после слова commit — это хеш коммита;
- Author — имя автора и его электронная почта;
- Date — дата и время создания коммита;
- в конце находится сообщение коммита.

<br>
Получить сокращённый лог можно с помощью команды git log с флагом --oneline (англ. «одной строкой»). В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии. <br>
Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда git log --oneline автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь. <br>


---

### Файл HEAD <br>

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый). <br>
В этом можно убедиться с помощью терминала. Перейдите в папку .git командой cd. Посмотрите содержимое файла HEAD командой cat.<br>
Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита. <br>
Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master. <br>
Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит. <br>

---

### Статусы файлов в Git<br>

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные. <br>

- untracked (англ. «неотслеживаемый») <br>

Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add. <br>

- staged (англ. «подготовленный») <br>

После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged. <br>
  
- tracked (англ. «отслеживаемый») <br>

Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения. <br>

- modified (англ. «изменённый») <br>

Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён. <br>

```
Для файлов в состояниях staged и modified обычно не указывают, что они также tracked, потому что это состояние подразумевается.
```

#### Про staged и modified

Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging.
Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз. <br>

#### Какие состояния показывает git status

Большинство файлов в типичном проекте будут находиться в состоянии tracked (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды git status — иначе она бы каждый раз выводила список вообще всех файлов проекта. <br>
В итоге git status показывает только следующие состояния файлов: <br>

- staged (Changes to be committed в выводе git status);
- modified (Changes not staged for commit);
- untracked (Untracked files).

## Схема жизненного цикла файла в git

```mermaid
graph LR;
untracked -- "git add" --> staged(в списке на коммит) + tracked;
staged(в списке на коммит) + tracked -- "git commit" --> tracked;
tracked -- "изменения" --> modified;
modified -- "git add" --> staged(в списке на коммит) + tracked;
staged(в списке на коммит) + tracked -- "изменения" --> modified;
```

---

Больше информации с примерами можно получить из курса [Яндекс Практикум по git.](https://practicum.yandex.ru) 